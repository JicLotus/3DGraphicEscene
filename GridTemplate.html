<!doctype html>
<meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type">
<meta content="ISO-8859-1" http-equiv="encoding">
<html >
    <head>
        <title>66.71 WebGL FrameWork</title>
        <style>
            body{ background-color: grey; }
            canvas{ background-color: white; }
			textarea{ background-color: black; foreground-color: white;}
        </style>

		<script type="text/javascript" src="funcionesInputs.js"></script>
        <script type="text/javascript" src="gl-matrix.js"></script>
        <script type="text/javascript" src="Objetos/Turbina.js"></script>
        <script type="text/javascript" src="Curvas/Punto.js"></script>
        <script type="text/javascript" src="Curvas/Bazier.js"></script>
        <script type="text/javascript" src="Curvas/CurvasExternasCentroEstacionEspacial.js"></script>
        <script type="text/javascript" src="Curvas/CurvasInternasCentroEstacionEspacial.js"></script>
        <script type="text/javascript" src="Curvas/CurvasCorazonEstacionEspacial.js"></script>
        <script type="text/javascript" src="Curvas/CurvasManguera.js"></script>
        <script type="text/javascript" src="Curvas/BSpline.js"></script>
        <script type="text/javascript" src="Curvas/ContenedorPunto.js"></script>
        <script type="text/javascript" src="Objetos/Grilla.js"></script>
        <script type="text/javascript" src="Objetos/Esfera.js"></script>
        <script type="text/javascript" src="Objetos/Cilindro.js"></script>
        <script type="text/javascript" src="Objetos/EstacionEspacial.js"></script>
        <script type="text/javascript" src="Objetos/TubosEstacionEspacial.js"></script>
        <script type="text/javascript" src="Objetos/PanelSolar.js"></script>
        <script type="text/javascript" src="Objetos/CentroBaseEspacialInterno.js"></script>
        <script type="text/javascript" src="Objetos/AlaNaveEspacial.js"></script>
        <script type="text/javascript" src="Objetos/CentroBaseEspacialExterno.js"></script>
        <script type="text/javascript" src="Objetos/TapaCentroBaseEspacial.js"></script>
        <script type="text/javascript" src="Objetos/CorazonNaveEspacial.js"></script>
        <script type="text/javascript" src="Objetos/NaveEspacial.js"></script>
        <script type="text/javascript" src="Objetos/Sol.js"></script>
        <script type="text/javascript" src="Objetos/Tierra.js"></script>
        <script type="text/javascript" src="Objetos/CuerpoNaveEspacial.js"></script>
        <script type="text/javascript" src="Objetos/TrompaNaveEspacial.js"></script>
        <script type="text/javascript" src="Objetos/PataNave.js"></script>
        <script type="text/javascript" src="Objetos/Manguera.js"></script>
        <script type="text/javascript" src="Objetos/SostenTurbinas.js"></script>
        <script type="text/javascript" src="Camaras/Camaras.js"></script>
        
        <!--
        Vertex shader
        El vertex shader define la posición y forma de cada vertice de cada polígono.
        --> 
        <script id="shader-vs" type="x-shader/x-vertex">
            // Los atributos son características propias de cada vertice.
            attribute vec3 aVertexPosition;
            attribute vec3 aVertexColor;
            attribute vec2 aTextureCoord;
            attribute vec3 aVertexNormal;

            // Los uniforms son características propias de una etapa de dibujado completa.
            // Son comunes a todos los vertices involucrados en el dibujado.
            
            uniform mat4 uPMatrix;
            uniform mat4 uVistaMatrix;
			uniform mat4 uMVMatrix;
			uniform mat3 uNMatrix;
      
            // Los varying son propiedades que toman valor para cada fragmento a partir
            // de interpolar linealmente entre los valores que se les asigna en cada 
            // vértice del polígono al cual pertenecen.
            varying highp vec4 vColor;    
			varying vec2 vTextureCoord;
			
			uniform vec3 uAmbientColor;
			uniform vec3 uLightPosition;
			uniform vec3 uDirectionalColor;
			uniform bool uUseLighting;
    
			varying vec3 vLightWeighting;
			
 
            void main(void) {
                // gl_Position es una variable "built-in" de GLSL que es usada para 
                // almacenar la posición resultante del fragmento.
                gl_Position = uPMatrix * uVistaMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
                
                vec3 light_dir_normalized =  normalize(uLightPosition - vec3( gl_Position ) );
				
				vec3 transformedNormal = normalize(uNMatrix * aVertexNormal);
				float directionalLightWeighting = max(dot(transformedNormal, light_dir_normalized), 0.0);

				vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
                vColor = vec4(aVertexColor,1.0);
            }
        </script>

        <!--
        Fragment shader

        Cada pixel en un polígono se llama fragmento. El fragment shader se encarga de
        establecer el color de cada pixel. En este caso, asignamos el color blanco a 
        cada pixel.
        -->
        <script id="shader-fs" type="x-shader/x-fragment">
			precision mediump float;
			
			varying highp vec4 vColor;
			varying vec3 vLightWeighting;

			void main(void) {
			  // gl_FragColor es una variable "built-in" de GLSL que es usada para 
			  // almacenar el color resultante del fragmento.
			  
			  gl_FragColor = vColor * vec4(vLightWeighting,1.0);
			}
			        
        </script>

		<script type="text/javascript" src="initialize.js"></script>

        <script>
            
            function drawScene()
            {
				
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                
                var u_proj_matrix = gl.getUniformLocation(glProgram, "uPMatrix");
                
                // Fovy y aspect definen el tamaño y la posicion de la ventana de recorte
                // Near y Far especifican las distancias entre el punto de vista y los planos de recorte proximo y lejano
                // Preparamos una matriz de perspectiva.
                mat4.perspective(pMatrix, fovy, aspect, near, far);
				
                gl.uniformMatrix4fv(u_proj_matrix, false, pMatrix);

                if (camara==1){
                    setMatrizLookAtNaveAtras();
                }else if (camara==2){
                    setMatrizLookAtNavePiloto();
                }else if (camara==3){
                    setMatrizLookAtAdentroEstacion();
                }else if (camara==4){
                    setMatrizLookAtVistaGeneral();
                }
				
                dibujarFiguras();
            }

			function dibujarFiguras()
			{
				var u_model_view_matrix = gl.getUniformLocation(glProgram, "uMVMatrix");
			
             
				var nMatrixUniform = gl.getUniformLocation(glProgram, "uNMatrix");
				var ambientColorUniform = gl.getUniformLocation(glProgram, "uAmbientColor");
				var lightingDirectionUniform = gl.getUniformLocation(glProgram, "uLightPosition");
				var directionalColorUniform = gl.getUniformLocation(glProgram, "uDirectionalColor");
 
				var lightPosition = [0.0, 0.0, 0.0];
		
				vec3.transformMat4(lightPosition,lightPosition,mvMatrix);
				gl.uniform3fv(lightingDirectionUniform, lightPosition); 
        
 				gl.uniform3f(ambientColorUniform,1.0, 1.0, 1.0);
			
				sol.draw(u_model_view_matrix);
				
				
                naveEspacial.setParametros(anguloRotacionTurbina, anguloRotacionAla, factorTrenAterrizaje);
                naveEspacial.step();
                naveEspacial.getMatriz();
                naveEspacial.draw(u_model_view_matrix);
 
				gl.uniform3f(ambientColorUniform, 0.2, 0.2, 0.2 );
				gl.uniform3f(directionalColorUniform, 0.8, 0.8, 0.8);
 
				tierra.draw(u_model_view_matrix);
				estacionEspacial.draw(u_model_view_matrix);
				
			}
			
        </script>
    </head>
    <body onload="initWebGL()" onkeyup="myKeyNotPressed(event)"   onmouseup="desclickear(event)" onmousedown="clickear(event)" onmousemove="coordenadas(event)" onkeydown="myKeyPress(event)" onwheel="ruedita(event)">
		<center>
			<canvas id="my-canvas" width="1024" height="600" >
			Your browser does not support the HTML5 canvas element.
			</scanvas>
			
		</center>
    </body>
</html>
