<!doctype html>
<meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type">
<meta content="ISO-8859-1" http-equiv="encoding">
<html >
    <head>
        <title>66.71 WebGL FrameWork</title>
        <style>
            body{ background-color: grey; }
            canvas{ background-color: white; }
			textarea{ background-color: black;}
        </style>

		<script type="text/javascript" src="funcionesInputs.js"></script>
        <script type="text/javascript" src="gl-matrix.js"></script>
        <script type="text/javascript" src="Objetos/Turbina.js"></script>
        <script type="text/javascript" src="Curvas/Punto.js"></script>
        <script type="text/javascript" src="Curvas/Bazier.js"></script>
        <script type="text/javascript" src="Curvas/CurvasExternasCentroEstacionEspacial.js"></script>
        <script type="text/javascript" src="Curvas/CurvasInternasCentroEstacionEspacial.js"></script>
        <script type="text/javascript" src="Curvas/CurvasCorazonEstacionEspacial.js"></script>
        <script type="text/javascript" src="Curvas/CurvasManguera.js"></script>
        <script type="text/javascript" src="Curvas/BSpline.js"></script>
        <script type="text/javascript" src="Curvas/ContenedorPunto.js"></script>
        <script type="text/javascript" src="Objetos/Grilla.js"></script>
        <script type="text/javascript" src="Objetos/Esfera.js"></script>
        <script type="text/javascript" src="Objetos/Cilindro.js"></script>
        <script type="text/javascript" src="Objetos/EstacionEspacial.js"></script>
        <script type="text/javascript" src="Objetos/TubosEstacionEspacial.js"></script>
        <script type="text/javascript" src="Objetos/PanelSolar.js"></script>
        <script type="text/javascript" src="Objetos/CentroBaseEspacialInterno.js"></script>
        <script type="text/javascript" src="Objetos/AlaNaveEspacial.js"></script>
        <script type="text/javascript" src="Objetos/CentroBaseEspacialExterno.js"></script>
        <script type="text/javascript" src="Objetos/TapaCentroBaseEspacial.js"></script>
        <script type="text/javascript" src="Objetos/CorazonNaveEspacial.js"></script>
        <script type="text/javascript" src="Objetos/NaveEspacial.js"></script>
        <script type="text/javascript" src="Objetos/Sol.js"></script>
        <script type="text/javascript" src="Objetos/Cielo.js"></script>
        <script type="text/javascript" src="Objetos/Tierra.js"></script>
        <script type="text/javascript" src="Objetos/CuerpoNaveEspacial.js"></script>
        <script type="text/javascript" src="Objetos/TrompaNaveEspacial.js"></script>
        <script type="text/javascript" src="Objetos/PataNave.js"></script>
        <script type="text/javascript" src="Objetos/Manguera.js"></script>
        <script type="text/javascript" src="Objetos/SostenTurbinas.js"></script>
        <script type="text/javascript" src="Camaras/Camaras.js"></script>
        
        <!--
        Vertex shader
        El vertex shader define la posición y forma de cada vertice de cada polígono.
        --> 
        <script id="shader-vs" type="x-shader/x-vertex">
            // Los atributos son características propias de cada vertice.
            attribute vec3 aVertexPosition;
            attribute vec3 aVertexColor;
            attribute vec2 aTextureCoord;
            attribute vec3 aVertexNormal;

            // Los uniforms son características propias de una etapa de dibujado completa.
            // Son comunes a todos los vertices involucrados en el dibujado.
            
            uniform mat4 uPMatrix;
            uniform mat4 uVistaMatrix;
			uniform mat4 uMVMatrix;
			uniform mat3 uNMatrix;
      
            // Los varying son propiedades que toman valor para cada fragmento a partir
            // de interpolar linealmente entre los valores que se les asigna en cada 
            // vértice del polígono al cual pertenecen.
            varying highp vec4 vColor;    
			varying vec2 vTextureCoord;
	
			uniform bool uUsarImagen;
			varying float vUsarImagen;
			
			varying vec3 view_dir_normalized;
			
			varying vec3 light_dir_normalized;
			varying vec3 light_dir_normalized2;
			varying vec3 light_dir_normalized3;
			
			varying vec3 transformedNormal;
			
			uniform bool lucesExternas;
			uniform vec3 l1Position;
			uniform vec3 l2Position;
			uniform vec3 l3Position;
			
			uniform vec3 eyePoint;
			
			varying float vLucesExternas;
			
			uniform bool uNormalMap;
			varying float vNormalMap;
			
            void main(void) {
                // gl_Position es una variable "built-in" de GLSL que es usada para 
                // almacenar la posición resultante del fragmento.
                
                // Transformamos al vértice al espacio de la cámara
				vec4 pos_camera_view = uVistaMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		
				// Transformamos al vértice al espacio de la proyección
				gl_Position = uPMatrix * pos_camera_view;
                
                vNormalMap=0.0;
                vTextureCoord = aTextureCoord;
                
                
                if (uUsarImagen){
					vUsarImagen = 1.0;
					
					if (uNormalMap) vNormalMap = 1.0;
				}
				else{
					vUsarImagen = 0.0;
                }
                
                
                if (lucesExternas){
					light_dir_normalized =  -normalize(vec3(uMVMatrix * vec4(aVertexPosition, 1.0)));
					view_dir_normalized = normalize(eyePoint - vec3(uMVMatrix * vec4(aVertexPosition, 1.0)));
					
					vLucesExternas=1.0;
                }else
                {
					light_dir_normalized =  normalize(l1Position-vec3(uMVMatrix * vec4(aVertexPosition, 1.0)));
					light_dir_normalized2 =  normalize(l2Position-vec3(uMVMatrix * vec4(aVertexPosition, 1.0)));
					light_dir_normalized3 =  normalize(l3Position-vec3(uMVMatrix * vec4(aVertexPosition, 1.0)));
					vLucesExternas=0.0;
				}
                
                
				transformedNormal = normalize(uNMatrix * aVertexNormal);
								
				
                vColor = vec4(aVertexColor,1.0);
                
            }
        </script>

        <!--
        Fragment shader

        Cada pixel en un polígono se llama fragmento. El fragment shader se encarga de
        establecer el color de cada pixel. En este caso, asignamos el color blanco a 
        cada pixel.
        -->
        <script id="shader-fs" type="x-shader/x-fragment">
			precision mediump float;
			
			
			varying highp vec4 vColor;
			varying vec2 vTextureCoord;
			
			uniform sampler2D uSampler;
			uniform sampler2D uNormalSampler;
			
			varying float vUsarImagen;
			
			varying float vLucesExternas;
			uniform vec3 uAmbientColor;
			uniform vec3 uDirectionalColor;
			uniform vec3 uEarthResplandor;
			
			
			varying vec3 light_dir_normalized;
			varying vec3 light_dir_normalized2;
			varying vec3 light_dir_normalized3;
			varying vec3 transformedNormal;
			
			varying vec3 view_dir_normalized;
			
			varying float vNormalMap;

			void main(void) {
				
				// gl_FragColor es una variable "built-in" de GLSL que es usada para 
				// almacenar el color resultante del fragmento.
				
				vec4 fragColor;
				
				if (vLucesExternas == 1.0){
					
					vec3 halfVector = normalize(light_dir_normalized + view_dir_normalized);
					
					float directionalLightWeighting = max(dot(transformedNormal, light_dir_normalized), 0.0);
					float directionalLightWeighting2 = max(dot(transformedNormal, vec3(0,-1,0)), 0.0);
					
					float specular=0.0;
					
					specular = pow(max(dot(transformedNormal, halfVector),0.0),50.0);
					
					
					if (vUsarImagen == 1.0){
						vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
						
						vec3 vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting + uEarthResplandor * directionalLightWeighting2;
						
						if (vNormalMap==1.0){
							vec4 textureNormalColor = texture2D(uNormalSampler, vec2(vTextureCoord.s, vTextureCoord.t));
							
							vec3 normalMap = normalize(textureNormalColor.rgb * 2.0 - 1.0);
							directionalLightWeighting =  max(dot(light_dir_normalized, normalMap), 0.0);
							
							vec3 vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
							
							fragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
						}
						else
						{
							fragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
						}
						
					}else{
						vec3 vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting + uEarthResplandor * directionalLightWeighting2;
						fragColor = vColor * vec4(vLightWeighting,1.0);}
						
					fragColor += specular;
					
						
				}else
				{
					float directionalLightWeighting = max(dot(transformedNormal, light_dir_normalized), 0.0);
					float directionalLightWeighting2 = max(dot(transformedNormal, light_dir_normalized2), 0.0);
					float directionalLightWeighting3 = max(dot(transformedNormal, light_dir_normalized3), 0.0);
					
					vec3 vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting + uDirectionalColor * directionalLightWeighting2 + uDirectionalColor * directionalLightWeighting3;				
					
					fragColor = vColor * vec4(vLightWeighting,1.0);
				}
				
				
				gl_FragColor = fragColor;
			}        
        </script>
        

		<script type="text/javascript" src="initialize.js"></script>

        <script>
            
            function drawScene()
            {
				
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                
                var u_proj_matrix = gl.getUniformLocation(glProgram, "uPMatrix");
                // Fovy y aspect definen el tamaño y la posicion de la ventana de recorte
                // Near y Far especifican las distancias entre el punto de vista y los planos de recorte proximo y lejano
                // Preparamos una matriz de perspectiva.
                mat4.perspective(pMatrix, fovy, aspect, near, far);
				
                dibujarFiguras();
            }

			function seleccionDeCamara()
			{
				camara = 4;
				
				if (camara==1){
                    setMatrizLookAtNaveAtras();
                }else if (camara==2){
                    setMatrizLookAtNavePiloto();
                }else if (camara==3){
                    setMatrizLookAtAdentroEstacion();
                }else if (camara==4){
                    setMatrizLookAtVistaGeneral();
                }
			}


			function dibujarFiguras()
			{
				var u_vista = gl.getUniformLocation(glProgram, "uVistaMatrix");
				var u_proj_matrix = gl.getUniformLocation(glProgram, "uPMatrix");
				var uUsarImagen = gl.getUniformLocation(glProgram, "uUsarImagen");
			
				var ambientColorUniform = gl.getUniformLocation(glProgram, "uAmbientColor");
				var lightingDirectionUniform = gl.getUniformLocation(glProgram, "uLightPosition");
				var directionalColorUniform = gl.getUniformLocation(glProgram, "uDirectionalColor");
				

				
				var lucesExternas = gl.getUniformLocation(glProgram, "lucesExternas");
				gl.uniform1i(lucesExternas, true);
        	
				
				var earthResplandor = gl.getUniformLocation(glProgram, "uEarthResplandor");
				gl.uniform3fv(earthResplandor, [0,0,0]); 
 
				//////////////////////////
        
                /////////////////////////////////////////////////////
				// Definimos la ubicación de la camara
				// Pensamos por el momento sunamente la posición de la cámara, la cual siempre mira al sun.
				
				seleccionDeCamara();
				
				//mat4.identity(CameraMatrix);
				//mat4.translate(CameraMatrix,CameraMatrix, [0, 0, -40]);
				
				gl.uniformMatrix4fv(u_proj_matrix, false, pMatrix);
				gl.uniformMatrix4fv(u_vista, false, CameraMatrix);
				////////////////////////////////////////////


				var eyePoint = gl.getUniformLocation(glProgram, "eyePoint");
				gl.uniform3fv(eyePoint, eye);        
        

				var usarImagen= true;
				gl.uniform1i(uUsarImagen, usarImagen);
        
 				gl.uniform3f(ambientColorUniform,1.0, 1.0, 1.0);
				sol.draw();
				cielo.draw();
				
				
				gl.uniform3f(ambientColorUniform, 0.2, 0.2, 0.2);
				gl.uniform3f(directionalColorUniform, 1.0, 1.0, 1.0);
				
				var usarImagen= false;
				gl.uniform1i(uUsarImagen, usarImagen);
				gl.uniform3fv(earthResplandor, [0.5,0.5,1]);
				
				
				estacionEspacial.draw();
				
				
				gl.uniform3fv(earthResplandor, [0,0,0]);
				
                naveEspacial.setParametros(anguloRotacionTurbina, anguloRotacionAla, factorTrenAterrizaje);
                naveEspacial.step();
                naveEspacial.getMatriz();
                naveEspacial.draw();
                
				
				var usarImagen= true;
				gl.uniform1i(uUsarImagen, usarImagen);
				
				tierra.draw();
				
				
			}
			
        </script>
    </head>
    <body onload="initWebGL()" onkeyup="myKeyNotPressed(event)"   onmouseup="desclickear(event)" onmousedown="clickear(event)" onmousemove="coordenadas(event)" onkeydown="myKeyPress(event)" onwheel="ruedita(event)">
		<center>
			<canvas id="my-canvas" width="1024" height="600" >
			Your browser does not support the HTML5 canvas element.
			</scanvas>
			
		</center>
    </body>
</html>
