<!doctype html>
<meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type">
<meta content="ISO-8859-1" http-equiv="encoding">
<html >
    <head>
        <title>66.71 WebGL FrameWork</title>
        <style>
            body{ background-color: grey; }
            canvas{ background-color: white; }
			textarea{ background-color: black;}
        </style>

		<script type="text/javascript" src="funcionesInputs.js"></script>
        <script type="text/javascript" src="gl-matrix.js"></script>
        <script type="text/javascript" src="Objetos/Turbina.js"></script>
        <script type="text/javascript" src="Curvas/Punto.js"></script>
        <script type="text/javascript" src="Curvas/Bazier.js"></script>
        <script type="text/javascript" src="Curvas/CurvasExternasCentroEstacionEspacial.js"></script>
        <script type="text/javascript" src="Curvas/CurvasInternasCentroEstacionEspacial.js"></script>
        <script type="text/javascript" src="Curvas/CurvasCorazonEstacionEspacial.js"></script>
        <script type="text/javascript" src="Curvas/CurvasManguera.js"></script>
        <script type="text/javascript" src="Curvas/BSpline.js"></script>
        <script type="text/javascript" src="Curvas/ContenedorPunto.js"></script>
        <script type="text/javascript" src="Objetos/Grilla.js"></script>
        <script type="text/javascript" src="Objetos/Esfera.js"></script>
        <script type="text/javascript" src="Objetos/Cilindro.js"></script>
        <script type="text/javascript" src="Objetos/EstacionEspacial.js"></script>
        <script type="text/javascript" src="Objetos/TubosEstacionEspacial.js"></script>
        <script type="text/javascript" src="Objetos/PanelSolar.js"></script>
        <script type="text/javascript" src="Objetos/CentroBaseEspacialInterno.js"></script>
        <script type="text/javascript" src="Objetos/AlaNaveEspacial.js"></script>
        <script type="text/javascript" src="Objetos/CentroBaseEspacialExterno.js"></script>
        <script type="text/javascript" src="Objetos/TapaCentroBaseEspacial.js"></script>
        <script type="text/javascript" src="Objetos/CorazonNaveEspacial.js"></script>
        <script type="text/javascript" src="Objetos/NaveEspacial.js"></script>
        <script type="text/javascript" src="Objetos/Sol.js"></script>
        <script type="text/javascript" src="Objetos/Cielo.js"></script>
        <script type="text/javascript" src="Objetos/Tierra.js"></script>
        <script type="text/javascript" src="Objetos/CuerpoNaveEspacial.js"></script>
        <script type="text/javascript" src="Objetos/TrompaNaveEspacial.js"></script>
        <script type="text/javascript" src="Objetos/PataNave.js"></script>
        <script type="text/javascript" src="Objetos/Manguera.js"></script>
        <script type="text/javascript" src="Objetos/SostenTurbinas.js"></script>
        <script type="text/javascript" src="Camaras/Camaras.js"></script>
        
        <!--
        Vertex shader
        El vertex shader define la posición y forma de cada vertice de cada polígono.
        --> 
        <script id="shader-vs" type="x-shader/x-vertex">
            // Los atributos son características propias de cada vertice.
            attribute vec3 aVertexPosition;
            attribute vec3 aVertexColor;
            attribute vec2 aTextureCoord;
            attribute vec3 aVertexNormal;

            // Los uniforms son características propias de una etapa de dibujado completa.
            // Son comunes a todos los vertices involucrados en el dibujado.
            
            uniform mat4 uPMatrix;
            uniform mat4 uVistaMatrix;
			uniform mat4 uMVMatrix;
			uniform mat3 uNMatrix;
      
            // Los varying son propiedades que toman valor para cada fragmento a partir
            // de interpolar linealmente entre los valores que se les asigna en cada 
            // vértice del polígono al cual pertenecen.
            varying highp vec4 vColor;    
			varying vec2 vTextureCoord;
			
			uniform vec3 uLightPosition;
			
    
			uniform bool uUsarImagen;
			varying float vUsarImagen;
			
			varying vec3 light_dir_normalized;
			varying vec3 transformedNormal;
 
            void main(void) {
                // gl_Position es una variable "built-in" de GLSL que es usada para 
                // almacenar la posición resultante del fragmento.
                
                // Transformamos al vértice al espacio de la cámara
				vec4 pos_camera_view = uVistaMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		
				// Transformamos al vértice al espacio de la proyección
				gl_Position = uPMatrix * pos_camera_view;
                
                if (uUsarImagen){
					vUsarImagen = 1.0;
					vTextureCoord = aTextureCoord; // Coordenada de textura sin modifiaciones
				}
				else{
					vUsarImagen = 0.0;
                }
                
                light_dir_normalized =  -normalize(vec3(uMVMatrix * vec4(aVertexPosition, 1.0)));
				transformedNormal = normalize(uNMatrix * aVertexNormal);
								
				
                vColor = vec4(aVertexColor,1.0);
                
            }
        </script>

        <!--
        Fragment shader

        Cada pixel en un polígono se llama fragmento. El fragment shader se encarga de
        establecer el color de cada pixel. En este caso, asignamos el color blanco a 
        cada pixel.
        -->
        <script id="shader-fs" type="x-shader/x-fragment">
			precision mediump float;
			
			
			varying highp vec4 vColor;
			varying vec2 vTextureCoord;
			uniform sampler2D uSampler;
			varying float vUsarImagen;
			
			
			uniform vec3 uAmbientColor;
			uniform vec3 uDirectionalColor;
			
			varying vec3 light_dir_normalized;
			varying vec3 transformedNormal;

			void main(void) {
				
				// gl_FragColor es una variable "built-in" de GLSL que es usada para 
				// almacenar el color resultante del fragmento.
				
				
				float directionalLightWeighting = max(dot(transformedNormal, light_dir_normalized), 0.0);
				vec3 vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
				
				
				vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
				vec4 fragColor;


				if (vUsarImagen == 1.0){
					fragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
				}else{
					fragColor = vColor * vec4(vLightWeighting,1.0);}


				gl_FragColor = fragColor;
			}
			
			        
        </script>

		<script type="text/javascript" src="initialize.js"></script>

        <script>
            
            function drawScene()
            {
				
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                
                var u_proj_matrix = gl.getUniformLocation(glProgram, "uPMatrix");
                // Fovy y aspect definen el tamaño y la posicion de la ventana de recorte
                // Near y Far especifican las distancias entre el punto de vista y los planos de recorte proximo y lejano
                // Preparamos una matriz de perspectiva.
                mat4.perspective(pMatrix, fovy, aspect, near, far);
				
                dibujarFiguras();
            }

			function seleccionDeCamara()
			{
				
				if (camara==1){
                    setMatrizLookAtNaveAtras();
                }else if (camara==2){
                    setMatrizLookAtNavePiloto();
                }else if (camara==3){
                    setMatrizLookAtAdentroEstacion();
                }else if (camara==4){
                    setMatrizLookAtVistaGeneral();
                }
			}


			function dibujarFiguras()
			{
				var u_vista = gl.getUniformLocation(glProgram, "uVistaMatrix");
				var u_proj_matrix = gl.getUniformLocation(glProgram, "uPMatrix");
				var uUsarImagen = gl.getUniformLocation(glProgram, "uUsarImagen");
			
				var ambientColorUniform = gl.getUniformLocation(glProgram, "uAmbientColor");
				var lightingDirectionUniform = gl.getUniformLocation(glProgram, "uLightPosition");
				var directionalColorUniform = gl.getUniformLocation(glProgram, "uDirectionalColor");

 
				
 
				//////////////////////////
				var lightPosition = [0.0, 0.0, 0.0];
		
				//vec3.transformMat4(lightPosition,lightPosition,CameraMatrix);
				gl.uniform3fv(lightingDirectionUniform, lightPosition); 
        
        
                /////////////////////////////////////////////////////
				// Definimos la ubicación de la camara
				// Pensamos por el momento sunamente la posición de la cámara, la cual siempre mira al sun.
				
				seleccionDeCamara();
				
				//mat4.identity(CameraMatrix);
				//mat4.translate(CameraMatrix,CameraMatrix, [0, 0, -40]);
				
				gl.uniformMatrix4fv(u_proj_matrix, false, pMatrix);
				gl.uniformMatrix4fv(u_vista, false, CameraMatrix);
				////////////////////////////////////////////
        
        
				var usarImagen= true;
				gl.uniform1i(uUsarImagen, usarImagen);
        
 				gl.uniform3f(ambientColorUniform,1.0, 1.0, 1.0);
				sol.draw();
				cielo.draw();
				
				
				gl.uniform3f(ambientColorUniform, 0, 0, 0);
				gl.uniform3f(directionalColorUniform, 1.0, 1.0, 1.0);
				
				
				var usarImagen= false;
				gl.uniform1i(uUsarImagen, usarImagen);
				
				estacionEspacial.draw();
				
				
                naveEspacial.setParametros(anguloRotacionTurbina, anguloRotacionAla, factorTrenAterrizaje);
                naveEspacial.step();
                naveEspacial.getMatriz();
                naveEspacial.draw();
                
				
				var usarImagen= true;
				gl.uniform1i(uUsarImagen, usarImagen);
				
				tierra.draw();
				
			}
			
        </script>
    </head>
    <body onload="initWebGL()" onkeyup="myKeyNotPressed(event)"   onmouseup="desclickear(event)" onmousedown="clickear(event)" onmousemove="coordenadas(event)" onkeydown="myKeyPress(event)" onwheel="ruedita(event)">
		<center>
			<canvas id="my-canvas" width="1024" height="600" >
			Your browser does not support the HTML5 canvas element.
			</scanvas>
			
		</center>
    </body>
</html>
